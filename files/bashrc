# shellcheck shell=bash

# Return immediately if non-interactive (makes FTP clients happy)
[[ "$-" == *i* ]] || return

##############################################################################
# Customize environment
##############################################################################

export XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
export XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"

export BACKGROUND="dark"
export EDITOR="vim"
export INPUTRC="$XDG_CONFIG_HOME/readline/inputrc"
export LANG="en_US.UTF-8"
export LANGUAGE="en_US"
export LC_ALL="en_US.UTF-8"
export LC_CTYPE="en_US.UTF-8"
export LESS="-i -j.49 -M -R -z-2"
export LESSHISTFILE="$XDG_DATA_HOME/less/history"
export LESSHISTSIZE=1000
export LOCAL_CONFIG="$HOME/.local/etc"
export LOCAL_PREFIX="/usr/local"
MANPATH="$(unset MANPATH; manpath)"
export MANPATH
export PAGER=less
export PYTHONSTARTUP="$XDG_CONFIG_HOME/python/startup.py"
# shellcheck disable=SC2016 # This expression is to be interpreted by vim, not bash.
export VIMINIT='let $MYVIMRC="$XDG_CONFIG_HOME/vim/vimrc" | source $MYVIMRC'

# Prevent path_helper from messing with the PATH when starting tmux.
#   See: https://superuser.com/a/583502
# shellcheck disable=SC2123 # PATH is being intentionally manipulated here.
# shellcheck disable=SC1091 # /etc/profile is provided by macOS.
[ "$(uname)" == "Darwin" ] && { PATH=""; source /etc/profile; }

_prepend_path() {  # prepend $1 to variable $2 using : as separator
    if [ -d "$1" ] && [ -n "$2" ]; then
        local _path="${!2}"                     # get path variable value
        case ":$_path:" in
            *":$1:"*) :;;                       # dir already in path, noop (:)
            *) _path="$1${_path:+:}$_path";;    # prepend (adding : if not empty)
        esac
        printf -v "$2" "%s" "$_path"            # write back to path variable
    fi
}

# Add custom bin dirs to PATH if they exist and are not already in PATH.
while read -r dir; do _prepend_path "$dir" PATH; done <<EOL
    $LOCAL_PREFIX/bin
    $LOCAL_PREFIX/opt/man-db/libexec/bin
    $LOCAL_PREFIX/opt/coreutils/libexec/gnubin
    $LOCAL_PREFIX/opt/gnu-sed/libexec/gnubin
    $HOME/.local/bin
EOL

# Prepend custom man directories to MANPATH if they exist, so that we get
# correct man page entries when multiple versions of a command are
# available.
while read -r dir; do _prepend_path "$dir" MANPATH; done <<EOL
    $LOCAL_PREFIX/share/man
    $LOCAL_PREFIX/opt/man-db/libexec/man
    $LOCAL_PREFIX/opt/coreutils/libexec/gnuman
    $LOCAL_PREFIX/opt/gnu-sed/libexec/gnuman
    $HOME/.local/share/man
EOL

unset dir _prepend_path

# This check has to be done after PATH manipulation above so we can find brew.
if command -v brew >/dev/null 2>&1; then
    LOCAL_PREFIX="$(brew --prefix)"
    export HOMEBREW_NO_ANALYTICS=1
    export HOMEBREW_NO_AUTO_UPDATE=1
fi

stty -ixon # disable ctrl-s and ctrl-q
command -v solarize >/dev/null && solarize

##############################################################################
# Customize shell options & variables
##############################################################################

shopt -s cdspell checkwinsize globstar histappend nocaseglob
set -o noclobber    # Prevent overwriting files with output redirection.

# Eternal bash history (from https://stackoverflow.com/a/19533853)
HISTCONTROL=erasedups
HISTFILESIZE=
HISTSIZE=
HISTTIMEFORMAT="[%F %T] "
HISTFILE="$XDG_DATA_HOME/bash/history"

Base03=8 Base02=0 Base01=10 Base00=11 Base0=12 Base1=14 Base2=7 Base3=15
Red=1 Orange=9 Yellow=3 Green=2 Cyan=6 Blue=4 Violet=13 Magenta=5

Reset="\[$(tput sgr0)\]"
PS1_EXIT="\[$(tput setaf      "$Red"    )\]"  # color for last exit code if non-zero
PS1_ROOT="\[$(tput setaf      "$Orange" )\]"  # logged in as root
PS1_SSH="\[$(tput setaf       "$Yellow" )\]"  # hostname for SSH sessions
PS1_PWD="\[$(tput setaf       "$Cyan"   )\]"  # PWD color
PS1_GIT="\[$(tput setaf       "$Blue"   )\]"  # color for git branch
PS1_VENV="\[$(tput setaf      "$Violet" )\]"  # color for python virtual env
PS1_JOBS="\[$(tput setaf      "$Magenta")\]"  # color for background jobs
PS1_SEP_LIGHT="\[$(tput setaf "$Base1"  )\]"
PS1_SEP_DARK="\[$(tput setaf  "$Base01" )\]"
PS1_SEP=" > "                           # separator between prompt parts

GIT_PS1_SHOWDIRTYSTATE=1
GIT_PS1_SHOWSTASHSTATE=1
GIT_PS1_SHOWUNTRACKEDFILES=1
GIT_PS1_SHOWUPSTREAM=verbose

PROMPT_COMMAND=__ps1_set
PS2="... "

__ps1_set() {
    local exit=$?
    local prompt=">>>>>>>>>>"
    local sep="$PS1_SEP_DARK$PS1_SEP"
    [ "$BACKGROUND" = "light" ] && sep="$PS1_SEP_LIGHT$PS1_SEP"

    local ps=()
    [ $exit -ne 0 ] && ps+=("$PS1_EXIT$exit")
    [ $EUID -eq 0 ] && { ps+=("$PS1_ROOT\u"); prompt="##########"; }
    [ -n "$SSH_CONNECTION" ] && ps+=("$PS1_SSH\h")
    ps+=("$PS1_PWD\w")
    type __git_ps1 && __git_ps1 '' '' "$PS1_GIT%s" && [ -n "$PS1" ] && ps+=("$PS1")
    [ -n "$VIRTUAL_ENV" ] && ps+=("$PS1_VENV${VIRTUAL_ENV##*/}")
    local j="\j" && [ "${j@P}" -gt 0 ] && ps+=("$PS1_JOBS${j@P} bg")

    local extra=""
    [ ${#ps[@]} -gt 1 ] && printf -v extra "$sep%s" "${ps[@]:1}"
    PS1="${ps[0]}$extra$Reset ${prompt:0:$SHLVL} "
} &>/dev/null

##############################################################################
# Customize shell aliases
##############################################################################

# ls:  make `ls` group directories first if supported.
# lsc: force `ls` to use color output (e.g. for piping into `less`).
if command -v exa >/dev/null; then
    alias ls="exa -F --git --group-directories-first --group --links -I'.git'"
    alias la="ls -a"
    alias lt="ls -lT"
    alias lta="ls -lTa"
    alias lsc="ls --color=always"
    alias ltc="lt --color=always"
elif ls --group-directories-first --color=auto &>/dev/null 2>&1; then
    # GNU ls
    alias ls="ls -hF --group-directories-first --color=auto"
    alias la="ls -A"
    alias lt="tree --dirsfirst -FI '.git|Spotlight-V100|.fseventsd'"
    alias lsc="ls --color=always"
    alias ltc="tree -C --dirsfirst -FI '.git'"
else
    # BSD ls (e.g. macOS)
    alias ls="ls -hF -G"
    alias la="ls -A"
    alias lt="tree --dirsfirst -FI '.git|Spotlight-V100|.fseventsd'"
    alias lsc="/usr/bin/env CLICOLOR_FORCE=1 ls"
    alias ltc="tree -C --dirsfirst -FI '.git'"
fi

alias ll="ls -l"
alias lla="la -l"

# Use my colorman wrapper if available.
command -v colorman >/dev/null && alias man=colorman

alias g='git'
alias v='vim'

alias grep="grep --color=auto"
alias egrep="egrep --color=auto"
alias fgrep="fgrep --color=auto"
alias path='echo $PATH | tr -s ":" "\n"'
alias mpath='echo $MANPATH | tr -s ":" "\n"'

alias tmux='tmux -f "$XDG_CONFIG_HOME/tmux/tmux.conf"'

# Head and tail as much as fits on screen
alias head='head -n $((${LINES:-15}-5))'
alias tail='tail -n $((${LINES:-15}-5))'

# A few options to get public IP address on command line. The dig solution
# below using the OpenDNS resolver doesn't work when connected to
# ExpressVPN because all DNS requests are handled by the ExpressVPN DNS
# servers and the OpenDNS DNS resolver is blocked.
alias ipinfo="curl -s ipinfo.io"
alias myip="curl -s https://ifconfig.co"
#alias myip="curl -s https://ifconfig.me"
#alias myip="dig +short myip.opendns.com @resolver1.opendns.com"

alias dark='change_bg dark'
alias light='change_bg light'

##############################################################################
# Add shell functions
##############################################################################

mkcd() { mkdir -p -- "$1" && cd -P -- "$1" || return; }

change_bg() { BACKGROUND="$1"; command -v solarize >/dev/null && solarize; }

##############################################################################
# Run external customizations
##############################################################################

_source_extra_configs() {
    local configs=(
        /usr/local/etc/profile.d/bash_completion.sh
        /usr/share/bash-completion/bash_completion
        $LOCAL_CONFIG/bash/*
    )
    local f
    for f in ${configs[@]}; do [ -f "$f" ] && source "$f"; done
}
_source_extra_configs

true
